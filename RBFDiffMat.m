% -------------------------------------------------------------------------
% RBFDiffMat
% Purpose: Given a vector describing which derivative to compute, an RBF
%          interpolation matrix structure, generated by RBFInterpMat, and
%          the desired evaluation points, a differentation matrix is computed.
%          
% [B,Psi] = RBFDiffMat(dervec,Psi,xe)
% Input:  dervec integer(dim) the element in position j tells how many
%                derivatives to take in the jth coordinate. For example (1,0,1)
%                represents the xz-derivative in an x,y,z-coordinate system. To
%                handle special operators, currently Laplacians of different
%                orders, we let -n in the first position denote the nth power
%                of the Laplacian \Delta^n.
%         xe     double(M,dim) the M evaluation points where the derivative
%                should be computed.
%
% Inout: Psi	 structure that contains the parameters of the RBF approximation
%                the node points, and the factorized interpolation matrix.
%                The content of the structure differs between RBF-Direct
%                approximations and RBF-QR approximations. Psi is updated
%                when new derivatives are computed with RBF-QR.
%
% Output: B	 double(M,N) the differentation matrix used for computing the
%                derivative Lu of the RBF approximation u at xe as Lu = B*u,
%                where u are the N nodal values at the center points xc.
%
% Example:       Compute the second derivative in y of sin(x*y) over 100
%                Halton points in [0,1]x[0,1];
%                dim = 2; N = 100; Mi = 30; derVec = [0,2];
%                phi = 'mq'; pdeg = -1; ep = 1;
%                xc = halton(N,dim);
%                xi = linspace(0,1,Mi); [xx,yy] = meshgrid(xi);
%                xe = [xx(:) yy(:)];
%                u = sin(prod(xc,2));
%                uyy = -xe(:,1).^2.*sin(prod(xe,2)));
%                Psi = RBFInterpMat(phi,pdeg,ep,xc);
%                [B,Psi] = RBFDiffMat(derVec,Psi,xe);
%                Lu = B*u;
%                err = Lu - uyy;
%                LuPlot = reshape(Lu,size(xx)); errPlot = reshape(err,size(xx));
%                figure, mesh(xx,yy,LuPlot), title('d^2u/dy^2')
%                figure, mesh(xx,yy,errPlot),title('Approximation error')
%
% Copyright (c) 2024 Elisabeth Larsson <elisabeth.larsson@it.uu.se>
%		       Andreas Michael <andreas.michael@it.uu.se >
% -------------------------------------------------------------------------
function [B,Te] = RBFDiffMat(ndiff,Psi,xTe)

if strcmp(Psi.phi,'rbfqr')
    dim = size(Psi.xk,2);
    if (dim==1)
        [B,Te] = RBF_QR_diffmat_1D(ndiff,Psi,xTe)
    elseif (dim==2)
        [B,Te] = RBF_QR_diffmat_2D(ndiff,Psi,xTe);
    elseif (dim==3)
        [B,Te] = RBF_QR_diffmat_3D(ndiff,Psi,xTe);
    end  
else
    xe = xTe; % Should always be the case for the direct method
    %
    % Scaling of the domain
    %
    rr = Psi.rr;
    cc = Psi.cc;
    Te = (xe - cc)./rr;  % In case the call is made with Te as an output
    % Te = xe;
    dim = size(Te,2);    
    compTrue = 0;
    if (ndiff > 0 & ndiff~=1.5) % Evaluation or Laplacian
        compTrue = 1; % Meaning that we need component distances as well
    end    
    re = xcdist(Te,Psi.xc,compTrue);
    [op,opDim,derVec]=getOpDirect(ndiff,dim);
    for k=1:length(op)
        B = RBFmat(Psi.phi,Psi.ep,re,op{k},opDim{k});

        np = 0;
        if (Psi.pdeg>=0)
            %
            % Add polynomial terms
            %
            P = polyMat(Te,Psi.pdeg,derVec{k}(1,:));
            for j=2:size(derVec,1)
                P = P + polyMat(Te,Psi.pdeg,derVec{k}(j,:));
            end    
            np = size(P,2);
            B = [B P];
        end
        %
        % Multiply with A0^{-1} from the right to get the differentiation matrix 
        %
        B = (B/Psi.U)/Psi.L; % Double check this again
        B(:,Psi.piv) = B;
        B = B(:,1:end-np);
        B = (1/rr).^ceil(sum(ndiff))*B;
        Bout{k} = B;
    end
    %
    % Now organize the output
    %
    if (ndiff==0 | ndiff==1.5)
        B = Bout{1};
    elseif (ndiff==1)
        B = Bout;
    elseif (ndiff==2)
        clear B
        for k = 1:length(op)
            if length(opDim{k}) == 1 
                B{opDim{k},opDim{k}} = Bout{k};
            else
                B{opDim{k}(1),opDim{k}(2)} = Bout{k};
                B{opDim{k}(2),opDim{k}(1)} = Bout{k};
            end
        end
    end    
end

function [op,opDim,derVec]=getOpDirect(ndiff,dim)
I = eye(dim);
if (ndiff==0)
    op{1} = '0';
    opDim{1} = 1;
    derVec{1} = zeros(1,dim);
elseif (ndiff==1)
    for k=1:dim
        op{k} = '1';
        opDim{k} = k;
        derVec{k} = I(k,:);
    end
elseif (ndiff==1.5)
    op{1} = 'L';
    opDim{1} = 1;
    derVec{1} = 2*I;
elseif (ndiff==2)
    pos = 1;
    for k=1:dim
        op{pos} = '2';
        opDim{pos} = k;
        derVec{pos} = 2*I(k,:);
        pos = pos + 1;
        for j=k+1:dim
            op{pos} = 'm2';
            opDim{pos} = [j k];
            derVec{pos} = I(k,:) + I(j,:);
            pos = pos + 1;
        end    
    end
elseif (ndiff > 2)
    if mod(ndiff,2)==0 % Positive values for higher order Laplacian
                       % We could also encode them with half numbers
        op{1} = strcat('L',num2str(ndiff/2));
        opDim{k} = 1;
        %
        % Add code here
        %
    end    
end





