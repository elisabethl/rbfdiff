% -------------------------------------------------------------------------
% RBFDiffMat
% Purpose: Given a vector describing which derivative to compute, an RBF
%          interpolation matrix structure, generated by RBFInterpMat, and
%          the desired evaluation points, a differentation matrix is computed.
%          
% B       = RBFDiffMat(ndiff,Psi,xe)
% [B,Te]  = RBFDiffMat(ndiff,Psi,xe)
% [B,Te]  = RBFDiffMat(ndiff,Psi,Te)
%
% Input:  ndiff  integer corresponding to the number of desired derivatives.
%                0 = func eval, 1 = gradient, 1.5 = Laplacian, 2 = Hessian,
%                4,6,... = higher order Laplacians, not implemented yet. 
%
%         xe     double(M,dim) the M evaluation points where the derivative
%                should be computed. Could also be Te, which for rbfqr keeps
%                some precomputed quantities.
%
%         Psi	 structure that contains the parameters of the RBF approximation
%                the node points, and the factorized interpolation matrix.
%                The content of the structure differs between RBF-Direct
%                approximations and RBF-QR approximations. Psi is updated
%                when new derivatives are computed with RBF-QR.
%
% Output: B	 cell array {double(M,N)} of the differentation matrices used
%                for computing a derivative Lu of the RBF approximation u at
%                xe as Lu = B*u,
%                where u are the N nodal values at the center points xc.
%
% Example:       Compute the Laplacian of sin(x*y) over 100
%                Halton points in [0,1]x[0,1];
%                dim = 2; N = 100; Mi = 30; ndiff = 1.5;
%                phi = 'mq'; pdeg = -1; ep = 1;
%                xc = halton(N,dim);
%                xi = linspace(0,1,Mi); [xx,yy] = meshgrid(xi);
%                xe = [xx(:) yy(:)];
%                u = sin(prod(xc,2));
%                uL = -(xe(:,1).^2+xe(:,2).^2).*sin(prod(xe,2));
%                porig = [0.5 0.5]; prad = sqrt(2)*0.5;
%                Psi = RBFInterpMat(phi,pdeg,ep,xc,porig,prad);
%                B = RBFDiffMat(ndiff,Psi,xe);
%                Lu = B*u;
%                err = Lu - uL;
%                LuPlot = reshape(Lu,size(xx)); errPlot = reshape(err,size(xx));
%                figure, mesh(xx,yy,LuPlot), title('\Delta u')
%                figure, mesh(xx,yy,log10(abs(errPlot))),title('Log_{10} of approximation error')
%
% Copyright (c) 2024 Elisabeth Larsson <elisabeth.larsson@it.uu.se>
%		       Andreas Michael <andreas.michael@it.uu.se >
% -------------------------------------------------------------------------
function [B,Te] = RBFDiffMat(ndiff,Psi,xTe)

if strcmp(Psi.phi,'rbfqr')
    dim = size(Psi.xk,2);
    if (dim==1)
        [B,Te] = RBF_QR_diffmat_1D(ndiff,Psi,xTe)
    elseif (dim==2)
        [B,Te] = RBF_QR_diffmat_2D(ndiff,Psi,xTe);
    elseif (dim==3)
        [B,Te] = RBF_QR_diffmat_3D(ndiff,Psi,xTe);
    end  
else
    xe = xTe; % Should always be the case for the direct method
    Te = xe; % to make it correct for calls with Te as output/input
    dim = size(xe,2);
    %
    % Scaling of the domain
    %
    rr = Psi.rr;
    cc = Psi.cc;
    xe = (xe - cc)./rr;  
    compTrue = 0;
    if (ndiff > 0 & ndiff~=1.5) % Evaluation or Laplacian
        compTrue = 1; % Meaning that we need component distances as well
    end    
    re = xcdist(xe,Psi.xloc,compTrue);
    [op,opDim,derVec]=getOpDirect(ndiff,dim);
    for k=1:length(op)
        B = RBFmat(Psi.phi,Psi.ep,re,op{k},opDim{k});

        np = 0;
        if (Psi.pdeg>=0)
            %
            % Add polynomial terms
            %
            P = polyMat(xe,Psi.pdeg,derVec{k}(1,:));
            for j=2:size(derVec{k},1)
                P = P + polyMat(xe,Psi.pdeg,derVec{k}(j,:));
            end    
            np = size(P,2);
            B = [B P];
        end
        %
        % Multiply with A0^{-1} from the right to get the differentiation matrix
        %
        B = (B/Psi.U)/Psi.L; % Double check this again
        B(:,Psi.piv) = B;
        B = B(:,1:end-np);
        B = (1/rr).^ceil(ndiff)*B; % Ceil for the Laplacian case with 1.5
        Bout{k} = B;
    end
    %
    % Now organize the output
    %
    if (ndiff==0 | ndiff==1.5)
        B = Bout{1};
    elseif (ndiff==1)
        B = Bout;
    elseif (ndiff==2)
        clear B
        for k = 1:length(op)
            if length(opDim{k}) == 1 
                B{opDim{k},opDim{k}} = Bout{k};
            else
                B{opDim{k}(1),opDim{k}(2)} = Bout{k};
                B{opDim{k}(2),opDim{k}(1)} = Bout{k};
            end
        end
    end    
end

function [op,opDim,derVec]=getOpDirect(ndiff,dim)
I = eye(dim);
if (ndiff==0)
    op{1} = '0';
    opDim{1} = 1;
    derVec{1} = zeros(1,dim);
elseif (ndiff==1)
    for k=1:dim
        op{k} = '1';
        opDim{k} = k;
        derVec{k} = I(k,:);
    end
elseif (ndiff==1.5)
    op{1} = 'L';
    opDim{1} = dim;
    derVec{1} = 2*I;
elseif (ndiff==2)
    pos = 1;
    for k=1:dim
        op{pos} = '2';
        opDim{pos} = k;
        derVec{pos} = 2*I(k,:);
        pos = pos + 1;
        for j=k+1:dim
            op{pos} = 'm2';
            opDim{pos} = [j k];
            derVec{pos} = I(k,:) + I(j,:);
            pos = pos + 1;
        end    
    end
elseif (ndiff > 2)
    if mod(ndiff,2)==0 % Even values for higher order Laplacian
                       
        op{1} = strcat('L',num2str(ndiff/2));
        opDim{k} = 1;
        %
        % Add code here
        %
    end    
end





