% -------------------------------------------------------------------------
% RBFDiffMat
% Purpose: Given a vector describing which derivative to compute, an RBF
%          interpolation matrix structure, generated by RBFInterpMat, and
%          the desired evaluation points, a differentation matrix is computed.
%          
% B       = RBFDiffMat(ndiff,Psi,xe)
% [B,Te]  = RBFDiffMat(ndiff,Psi,xe)
% [B,Te]  = RBFDiffMat(ndiff,Psi,Te)
%
% Input:  ndiff  integer corresponding to the number of desired derivatives.
%                0 = func eval, 1 = gradient, 1.5 = Laplacian, 2 = Hessian,
%                3, 4 = third and fourth order derivatives, implemented for
%                some basis functions 3.5, 5.5, 7.5,6 = higher order Laplacians,
%                only implemented for some basis functions. 
%
%         xe     double(M,dim) the M evaluation points where the derivative
%                should be computed. Could also be Te, which for rbfqr keeps
%                some precomputed quantities.
%
%         Psi	 structure that contains the parameters of the RBF approximation
%                the node points, and the factorized interpolation matrix.
%                The content of the structure differs between RBF-Direct
%                approximations and RBF-QR approximations. Psi is updated
%                when new derivatives are computed with RBF-QR.
%
% Output: B	 cell array {double(M,N)} of the differentation matrices used
%                for computing a derivative Lu of the RBF approximation u at
%                xe as Lu = B*u,
%                where u are the N nodal values at the center points xc.
%                Note the higher derivatives are stored such that B{i,j,k} gives
%                the ijk-derivative, which each index taking values from 1..d.
%                However, values are returned only for k>=j>=i, since the other
%                combinations are redundant.
%
% Example:       Compute the Laplacian of sin(x*y) over 100
%                Halton points in [0,1]x[0,1];
%                dim = 2; N = 100; Mi = 30; ndiff = 1.5;
%                phi = 'mq'; pdeg = -1; ep = 1;
%                xc = halton(N,dim);
%                xi = linspace(0,1,Mi); [xx,yy] = meshgrid(xi);
%                xe = [xx(:) yy(:)];
%                u = sin(prod(xc,2));
%                uL = -(xe(:,1).^2+xe(:,2).^2).*sin(prod(xe,2));
%                porig = [0.5 0.5]; prad = sqrt(2)*0.5;
%                Psi = RBFInterpMat(phi,pdeg,ep,xc,porig,prad);
%                B = RBFDiffMat(ndiff,Psi,xe);
%                Lu = B*u;
%                err = Lu - uL;
%                LuPlot = reshape(Lu,size(xx)); errPlot = reshape(err,size(xx));
%                figure, mesh(xx,yy,LuPlot), title('\Delta u')
%                figure, mesh(xx,yy,log10(abs(errPlot))),title('Log_{10} of approximation error')
%
% Copyright (c) 2024 Elisabeth Larsson <elisabeth.larsson@it.uu.se>
%		       Andreas Michael <andreas.michael@it.uu.se >
% -------------------------------------------------------------------------
function [B,Te] = RBFDiffMat(ndiff,Psi,xTe)
%
% Check that the input ndiff is compatible with what is implemented
%
ndiff = round(2*ndiff)/2; % Only integer and half integer values are ok
errstr = ['Derivative ' num2str(ndiff) ' is not implemented for ' Psi.phi];
if (ndiff < 0 | ndiff > 7.5)
    error(errstr)
end    
switch Psi.phi
  case 'rbfqr'
    if (ndiff > 2)
        if (dim<3 | ~any(2*ndiff==2*[4 6 8]-1))
            error(errstr)
        end
    end
  case {'gs','mq','iq','bmp'}
    if (ndiff > 4)
        error(errstr)
    end
  case 'phs'
    if (ndiff>Psi.ep) % Psi.ep is the order of the phs
        error(errstr)
    end
  case 'w2'
    if (ndiff>2)
        error(errstr)
    end
end

if strcmp(Psi.phi,'rbfqr')
    dim = size(Psi.xk,2);
    if (dim==1)
        [B,Te] = RBF_QR_diffmat_1D(ndiff,Psi,xTe);
    elseif (dim==2)
        [B,Te] = RBF_QR_diffmat_2D(ndiff,Psi,xTe);
    elseif (dim==3)
        [B,Te] = RBF_QR_diffmat_3D(ndiff,Psi,xTe);
    end  
else
    xe = xTe; % Should always be the case for the direct method
    Te = xe; % to make it correct for calls with Te as output/input
    dim = size(xe,2);
    %
    % Scaling of the domain
    %
    rr = Psi.rr;
    cc = Psi.cc;
    xe = (xe - cc)./rr;  
    compTrue = 0;
    if (ndiff > 0 & ndiff~=1.5) % Evaluation or Laplacian
        compTrue = 1; % Meaning that we need component distances as well
    end    
    re = xcdist(xe,Psi.xloc,compTrue);
    [op,opDim,derVec]=getOpDirect(ndiff,dim);
    for k=1:length(op)
        B = RBFmat(Psi.phi,Psi.ep,re,op{k},opDim{k});

        np = 0;
        if (Psi.pdeg>=0)
            %
            % Add polynomial terms
            %
            P = polyMat(xe,Psi.pdeg,derVec{k}(1,:));
            for j=2:size(derVec{k},1)
                P = P + polyMat(xe,Psi.pdeg,derVec{k}(j,:));
            end    
            np = size(P,2);
            B = [B P];
        end
        %
        % Multiply with A0^{-1} from the right to get the differentiation matrix
        %
        B = (B/Psi.U)/Psi.L; % Double check this again
        B(:,Psi.piv) = B;
        B = B(:,1:end-np);
        B = (1/rr).^ceil(ndiff)*B; % Ceil for the Laplacian case with 1.5
        Bout{k} = B;
    end
    %
    % Now organize the output
    %
    if (ndiff==0 | ndiff==1.5 | ndiff==3.5 | ndiff==5.5 | ndiff==7.5)
        B = Bout{1};
    elseif (ndiff==1)
        B = Bout;
    elseif (ndiff==2)
        clear B
        for k = 1:length(op)
            if length(opDim{k}) == 1 
                B{opDim{k},opDim{k}} = Bout{k};
            else
                B{opDim{k}(1),opDim{k}(2)} = Bout{k};
                B{opDim{k}(2),opDim{k}(1)} = Bout{k};
            end
        end
    elseif (ndiff==3)
        clear B
        % We only return the non-redundant upper triangular part of derivatives
        for k = 1:length(op)
            opDim{k} = sort(opDim{k});
            if length(opDim{k}) == 1 
                B{opDim{k},opDim{k},opDim{k}} = Bout{k};
            else % Then length = 3
                B{opDim{k}(1),opDim{k}(2),opDim{k}(3)} = Bout{k};
            end
        end
    elseif (ndiff==4)
        clear B
        % We only return the non-redundant upper triangular part of derivatives
        for k = 1:length(op)
            opDim{k} = sort(opDim{k});
            if length(opDim{k}) == 1 
                B{opDim{k},opDim{k},opDim{k},opDim{k}} = Bout{k};
            else
                B{opDim{k}(1),opDim{k}(2),opDim{k}(3),opDim{k}(4)} = Bout{k};
            end
        end
    end    
end

function [op,opDim,derVec]=getOpDirect(ndiff,dim)
I = eye(dim);
if (ndiff==0)
    op{1} = '0';
    opDim{1} = 1;
    derVec{1} = zeros(1,dim);
elseif (ndiff==1)
    for k=1:dim
        op{k} = '1';
        opDim{k} = k;
        derVec{k} = I(k,:);
    end
elseif (ndiff==1.5)
    op{1} = 'L';
    opDim{1} = dim;
    derVec{1} = 2*I;
elseif (ndiff==2)
    pos = 1;
    for k=1:dim
        op{pos} = '2';
        opDim{pos} = k;
        derVec{pos} = 2*I(k,:);
        pos = pos + 1;
        for j=k+1:dim
            op{pos} = 'm2';
            opDim{pos} = [j k];
            derVec{pos} = I(k,:) + I(j,:);
            pos = pos + 1;
        end    
    end
elseif (ndiff==3)
    pos = 1;
    for k=1:dim
        op{pos} = '3';
        opDim{pos} = k;
        derVec{pos} = 3*I(k,:);
        pos = pos + 1;
        for j=k:dim % Allowing for two derivatives in one coordinate
            for ell = k+1:dim % But the third needs to be different 
                op{pos} = 'm3';
                opDim{pos} = [k j ell];
                derVec{pos} = I(k,:) + I(j,:) + I(ell,:);
                pos = pos + 1;
            end    
        end
    end
elseif (ndiff==4)
    pos = 1;
    for k=1:dim
        op{pos} = '4';
        opDim{pos} = k;
        derVec{pos} = 4*I(k,:);
        pos = pos + 1;
        for j=k:dim
            for ell=k:dim
                for m=k+1:dim % Last derivative cannot be k
                    op{pos} = 'm4';
                    opDim{pos} = [j k ell m];
                    derVec{pos} = I(k,:) + I(j,:) + I(ell,:) + I(m,:);
                    pos = pos + 1;
                end
            end
        end    
    end
elseif (ndiff == 3.5)
    op{1} = 'L2'; % The squared Laplacian
    opDim{1} = dim;
    derVec{1} = zeros(0,dim);
    % This is slightly inefficient for the polynomial part since mixed
    % terms appear twice, but ok.
    for k=1:dim 
        for j=1:dim
            derVec{1} = [derVec{1}; 2*I(k,:) + 2*I(j,:)];
        end    
    end    
elseif (ndiff == 5.5)
    op{1} = 'L3'; % The cubed Laplacian
    opDim{1} = dim;
    derVec{1} = zeros(0,dim);
    % This is slightly inefficient for the polynomial part since mixed
    % terms appear twice, but ok.
    for k=1:dim 
        for j=1:dim
            for ell=1:dim
                derVec{1} = [derVec{1}; 2*I(k,:) + 2*I(j,:) + 2*I(ell,:)];
            end    
        end    
    end    
elseif (ndiff == 7.5)
    op{1} = 'L4'; % The squared-squared Laplacian
    opDim{1} = dim;
    derVec{1} = zeros(0,dim);
    % This is slightly inefficient for the polynomial part since mixed
    % terms appear twice, but ok.
    for k=1:dim 
        for j=1:dim
            for ell=1:dim
                for m=1:dim
                    derVec{1} = [derVec{1}; 2*I(k,:) + 2*I(j,:) + 2*I(ell,:) + 2*I(m,:)];
                end    
            end    
        end    
    end    
end





