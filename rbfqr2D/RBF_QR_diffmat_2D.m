function [out1,out2,out3]=RBF_QR_diffmat_2D(ndiff,varargin)
% Alternative calls:
%        Psi = RBF_QR_diffmat(ndiff,xk,ep,C,R) % First time fix domain
% [A,Psi,Te] = RBF_QR_diffmat(ndiff,xk,ep,xe)  % First time implicit domain 
%     [A,Te] = RBF_QR_diffmat(ndiff,Psi,xe)    % If Psi is already computed
%     [A,Te] = RBF_QR_diffmat(ndiff,Psi,Te)    % If Psi and Te exist
%
% Computes a differentiation matrix (weights for RBF-FD stencils)
% using Gaussian RBFs at evaluation point(s) xe for RBFs placed at
% the nodes xk. 
%
%--- op (char)   : Alternatives '1', 'x', 'y', 'xx', 'xy', 'yy' ,'L',
%                   'Ln' where n is a number indicating the degree
%                   of the Laplacian.
%--- xe(1:M,1:2)  : The evaluation point(s) in Cartesian coordinates
%--- xk(1:N,1:2)  : The node points (no particular scaling assumed)
%--- ep (scalar)  : The (constant) shape parameter 
%--- Psi (struct) : Generated by a call to this function. Defines
%                   the RBF-QR basisfunctions Psi.
%
%--- Check if Psi exists. Otherwise, scale nodes and compute Psi.
computePsi = length(varargin) > 2;
evalTrue = length(varargin) <= 3;
domainGiven =  length(varargin) == 4;

if computePsi
    xk = varargin{1};
    ep = varargin{2};
    %
    % Find the center of the RBF-QR expansion, and center xk.
    %
    if domainGiven
        cc = varargin{3};
        rr = varargin{4};
    else
        xe = varargin{3};
        if (size(xe,1) > 1) % Regular case
            cc = mean(xk); % The nodes mainly define the domain 
        else
            cc = xe; % Stencil case, (the one) eval point = origin
        end
        xe = xe - cc;
        re = sqrt(sum(xe.^2,2));
        rr = max(re);
    end
    xk = xk - cc;
    rk = sqrt((sum(xk.^2,2)));
    rr = max(rr,max(rk)); % For a fixed domain, no nodes should be outside
    %
    % Transform the nodes to polar and scale the nodes to radius one
    %
    xk = [(1/rr)*rk atan2(xk(:,2),xk(:,1))];
    ep = ep*rr;
    %
    % Compute Psi and save the transformation
    %
    [Psi] = InitPsi_2D(ep,xk);
    Psi.rr = rr;
    Psi.cc = cc;
    %--- Also compute the interpolation matrix which is reused for all ops 
    Psi.A0 = RBF_QR_mat_2D(Psi,'1',Psi.xk);

    %--- Factorize it and store the factors
    [Psi.L,Psi.U,Psi.piv] = lu(Psi.A0,'vector');
else
    Psi = varargin{1};
    xe = varargin{2};
    if ~isstruct(xe)
        xe = xe - Psi.cc; % Already done for the other case
        re = sqrt(sum(xe.^2,2));
    end    
end

if evalTrue
    if ~isstruct(xe)
        xe = [(1/Psi.rr)*re atan2(xe(:,2),xe(:,1))]; % Polar coordinates
    end    

    if (ndiff==0)
        [A,Te] = eval_diffmat(Psi,'1',xe);

    elseif (ndiff == 1)
        [A{1},Te] = eval_diffmat(Psi,'x',xe);
        [A{2},Te] = eval_diffmat(Psi,'y',Te);

    elseif (ndiff == 1.5)
        [A,Te] = eval_diffmat(Psi,'L',xe);

    elseif (ndiff == 2)
        [A{1,1},Te] = eval_diffmat(Psi,'xx',xe);
        [A{1,2},Te] = eval_diffmat(Psi,'xy',Te);
        [A{2,2},Te] = eval_diffmat(Psi,'yy',Te);
        A{2,1} = A{1,2};
    end
    %
    % Higher order Laplacians can be added
    %
end
 
out1 = []; out2 = []; out3 = [];
if (domainGiven)
    out1 = Psi;
else
    out1 = A;
    if (computePsi)
        out2 = Psi;
        out3 = Te;
    else
        out2 = Te;
    end
end

function [A,Te] = eval_diffmat(Psi,op,xe)
%--- Compute the differentiation matrix
[A,Te] = RBF_QR_mat_2D(Psi,op,xe); % Note that xe can be xe or Te
A = (A/Psi.U)/Psi.L;
A(:,Psi.piv) = A;
%--- Adjust the scaling according to derivative
deg = RBF_QR_parse(op);
A = (1/Psi.rr).^deg*A;

