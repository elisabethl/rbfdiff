function [l2Error, h] = RBFFD_Poisson(pars)

dim = pars.dim;                            % dim = 1,2 or 3
display = pars.display;                        % Plot solution
geom = pars.geom;                      % ball or cube
mode = pars.mode;                    % fitted, unfitted or collocation
scaling = pars.scaling;                        % Include scaling of the unfitted LS problem
mvCentres = pars.mvCentres;                      % Option to have a Y point on top of all X points inside the domain
q = pars.q;                              % Oversampling
N = pars.N;                             % Number of center points (X) in each patch
ep = pars.ep;                           % Not relevant for 'r3' basis
phi = pars.phi;                      % Choice of basis 'r3', 'mq', 'gs', 'iq', 'rbfqr'
pdeg = pars.pdeg;                          % Polynomial extension, not relevant for 'rbfqr'
rbfdeg = pars.rbfdeg;
extCoeff = pars.extCoeff;

if pdeg == -1
    n = nchoosek(rbfdeg+dim-1,dim); % Order in smooth RBF case
else
    n = 2*nchoosek(pdeg+dim,dim);   % Stencil size
end
if N < n
    warning("RBFFD: The number of centre points are less than the stencil points required for the given polynomial order. N is increased.")
    N = n;
end
extCoeff = extCoeff*(strcmp(mode,"unfitted"));

%
% Place N centre points and M evaluation points in geom with centre C and radius R
%
C = zeros(1,dim);
if strcmp(geom,'cube')
    R = 1*(dim)^(1/2);
elseif strcmp(geom,'ball')
    R = 1;
else
    disp("Requested geometry not implemented yet");
    return;
end
[dataX] = getPts(geom,N,n,C,R,mode,extCoeff);
xc = dataX.nodes;                                     
% 
% For collocation, evaluation and centre points match
%
if strcmp(mode,"collocation")
    M = N;                                      % Number of evaluation points (Y)
    dataY = dataX;
    xe = dataY.nodes;
else
    M = q*N;                                    % Number of evaluation points (Y)
    [dataY] = getPts(geom,M,n,C,R,"fitted",0);
    %
    % Move evaluation points inside (and on the boundary) to the closest center point.
    % Make sure not to move two evaluation points to the same center point. All
    % center points should be moved to.
    %
    if mvCentres
        xcIn = xc([dataX.inner; dataX.bnd],:);
        xeIn = dataY.nodes([dataY.inner; dataY.bnd],:);
        i = 1;
        idY = [1:size(xeIn,1)]'; % All interior evaluation (Y) points
        idX = [1:size(xcIn,1)]'; % All interior center (X) points
        %
        % Ensure the same Y point is not moved twice and obly consider X
        % points that have not been treated
        %
        iXdone = [];             
        iYdone = [];
        while length(iXdone) ~= size(xcIn,1) % ensure all interior center points are treated
            idYmv = knnsearch(xeIn(idY,:),xcIn(idX,:),'k',1);
            [unIdYmv,iX,~] = unique(idYmv,'first');
            xeIn(idY(unIdYmv),:) = xcIn(idX(iX),:);
            iXdone = [iXdone; idX(iX)];
            iYdone = [iYdone; idY(unIdYmv)];
            i = i + 1;
            idY = setdiff(idY,iYdone);
            idX = setdiff(idX,iXdone);
        end
        dataY.nodes([dataY.inner; dataY.bnd],:) = xeIn;
    end
    xe = dataY.nodes;
end
%
% Ensure center points are not too far from boundary and make evaluation point - stencil list 
%
if strcmp(mode,"unfitted")
    xc = xc(unique(knnsearch(xc,xe,'K',ceil(extCoeff*n+eps(1)))),:);
    N = size(xc,1);
end
ptStencilList = knnsearch(xc,xe,'K',1);
relXc = unique(ptStencilList); % stencil centres that are used directly
%
% Constructing global LS-RBF-FD approximation to evaluation and Laplace operators M x N
%
Eglobal = spalloc(M,N,M*n);
Lglobal = spalloc(M,N,M*n);
for i = 1:length(relXc)
    [idX,~] = knnsearch(xc,xc(relXc(i),:),'K',n);
    xcLoc = xc(idX,:); % stencil
    Psi = RBFInterpMat(phi,pdeg,ep,xcLoc,xcLoc(1,:),max(sqrt(sum((xcLoc-xcLoc(1,:)).^2,2))));
    idY = find(ptStencilList==relXc(i));
    E = RBFDiffMat(0,Psi,xe(idY,:));
    L = RBFDiffMat(1.5,Psi,xe(idY,:));
    
    Eglobal(idY,idX) = E + Eglobal(idY,idX);
    Lglobal(idY,idX) = L + Lglobal(idY,idX);
end
L = Lglobal(dataY.inner,:);
B = Eglobal(dataY.bnd,:);
%
% Manufactured solution to construct forcing and BC
%
if dim == 1
    fun = @(x) sin(2.*pi.*x);
    lapFun = @(x) -4.*(pi.^2).*sin(2.*pi.*x);
    F = [lapFun(xe(dataY.inner,1)); fun(xe(dataY.bnd,1))];
    uExact = fun(xe(:,1));
    ucExact = fun(xc(:,1));
    lapAnalytic = lapFun(xe(dataY.inner,1));
    bndAnalytic = [0; 0];
elseif dim == 2
    fun = @(x,y) sin(2.*pi.*x.*y);
    lapFun = @(x,y) - 4.*(x.^2).*(pi.^2).*sin(2.*pi.*x.*y) - 4.*(y.^2).*(pi.^2).*sin(2.*pi.*x.*y);
    F = [lapFun(xe(dataY.inner,1),xe(dataY.inner,2)); fun(xe(dataY.bnd,1),xe(dataY.bnd,2))];
    uExact = fun(xe(:,1),xe(:,2));
    ucExact = fun(xc(:,1),xc(:,2));
    lapAnalytic = lapFun(xe(dataY.inner,1),xe(dataY.inner,2));
    bndAnalytic = fun(xe(dataY.bnd,1),xe(dataY.bnd,2));
elseif dim == 3
    fun = @(x,y,z) sin(2.*pi.*x.*y.*z);
    lapFun = @(x,y,z) - 4.*(x.^2).*(y.^2).*(pi.^2).*sin(2.*pi.*x.*y.*z) - 4.*(y.^2).*(z.^2).*(pi.^2).*sin(2.*pi.*x.*y.*z) - 4.*(x.^2).*(z.^2).*(pi.^2).*sin(2.*pi.*x.*y.*z);
    F = [lapFun(xe(dataY.inner,1),xe(dataY.inner,2),xe(dataY.inner,3)); fun(xe(dataY.bnd,1),xe(dataY.bnd,2),xe(dataY.bnd,3))];
    uExact = fun(xe(:,1),xe(:,2),xe(:,3));
    ucExact = fun(xc(:,1),xc(:,2),xc(:,3));
    lapAnalytic = lapFun(xe(dataY.inner,1),xe(dataY.inner,2),xe(dataY.inner,3));
    bndAnalytic = fun(xe(dataY.bnd,1),xe(dataY.bnd,2),xe(dataY.bnd,3));
end 
%
% LS problem scaling
%
if scaling && strcmp(mode,"unfitted")
    [~,dist] = knnsearch(xc,xc,'K',2);
    h = max(dist(:,2));
    Lscale = sqrt(dataY.Vol/length(dataY.inner));
    Bscale = sqrt(dataY.Area/length(dataY.bnd))*(h.^-1.5);
    L = Lscale.*L; B = Bscale.*B;
    F(dataY.inner) = Lscale.*F(dataY.inner);
    F(dataY.bnd) = Bscale.*F(dataY.bnd);
end

if strcmp(mode,"fitted")
    Fmod = Lglobal(:,dataX.bnd)*ucExact(dataX.bnd);
    F = F-Fmod;
    L = Lglobal(:,dataX.inner);
    B = zeros(0,N);
end
%
% Solution on centre points, evaluated on Y set
%
A = [L; B];
u = A\F;
%
% Fix operators to compute error measures
%
if strcmp(mode,"fitted")
    u = [u; ucExact(dataX.bnd)];
end
ue = Eglobal*u;
l2Error = norm(abs(ue-uExact),2)/norm(uExact,2);
%
% Displaying output 
%
if display
    if dim == 1
        evalPtPlot = plot(xe,zeros(size(xe,1),1),'b.');
        centerPtPlot = plot(xc,zeros(size(xc,1),1),'rx');
    elseif dim == 2
        theta = linspace(0,2*pi,1000);
        domainPlot = plot(R.*cos(theta),R.*sin(theta),'b-','LineWidth',2);
        hold on;
        centerPtPlot = plot(xc(:,1),xc(:,2),'rx','MarkerSize',8,'LineWidth',3);
        if ~strcmp(mode,"collocation")
            evalPtPlot = plot(xe(:,1),xe(:,2),'b.','MarkerSize',8);
        end
    elseif dim == 3
        evalPtPlot = plot3(xe(:,1),xe(:,2),xe(:,3),'b.');
        hold on
        centerPtPlot = plot3(xc(:,1),xc(:,2),xc(:,3),'rx');
    end
    ax = gca;
    ax.FontSize = 18;
    xlabel("x",'Interpreter','latex','FontSize',20)
    ylabel("y",'Interpreter','latex','FontSize',20,'Rotation',0)
    xlim([-1.75 1.75]);
    ylim([-1.75 1.2]);
    if strcmp(mode,"unfitted")
        l = legend('Domain, $\Omega$','Centre points','Eval points','Interpreter','latex','location','south','Orientation','Horizontal');
        % l.NumColumns = 1;
        l.FontSize = 20; 
    else
        l = legend('Domain, $\Omega$','Centre points','Interpreter','latex','location','south','Orientation','Horizontal');
        l.FontSize = 20; 
    end

    % Plotting 
    plotSolution(ue,uExact,xe,dataY.bnd,dim,geom);
    %
    % Operator and solution l2 errors
    %
    lapNumeric = Lglobal(dataY.inner,:)*ucExact;
    evalNumeric = Eglobal(dataY.bnd,:)*ucExact;
    laplaceError = norm(lapAnalytic-lapNumeric,2)/norm(lapAnalytic,2);
    bndError = norm(evalNumeric-bndAnalytic,2)/(norm(bndAnalytic,2) + double(max(abs(bndAnalytic))==0));
    disp(['PDE error = ', num2str(l2Error)]);
    disp(['Boundary Op error = ', num2str(bndError)]);
    disp(['Laplace Op error = ', num2str(laplaceError)]);
end
%
% Plotting routines
%
function [] = plotSolution(uNumeric,uAnalytic,x,idB,dim,geom)
    error = uNumeric-uAnalytic;
    if dim == 1
        [x,id] = sort(x);
        figure()
        plot(x,uAnalytic(id),'r-'); 
        hold on;
        plot(x,uNumeric(id),'bo');
        ax = gca;
        ax.FontSize = 18;
        xlabel("x","Interpreter","latex","FontSize",24)
        ylabel("$$u$$","Interpreter","latex","FontSize",24,'Rotation',0)
        legend('$u_E$','$u_N$','FontSize',18,'Interpreter','latex');
        grid on
    
        figure()
        plot(x,error(id),'b-.');
        ax = gca;
        ax.FontSize = 18;
        xlabel("x","Interpreter","latex","FontSize",24)
        ylabel("$e_{rel}$","Interpreter","latex","FontSize",24,'Rotation',0)
        grid on
    elseif dim == 2
        T = delaunay(x(:,1),x(:,2));

        figure()
        G=trisurf(T,x(:,1),x(:,2),uAnalytic);
        hold on
        if strcmp(geom,"ball")
            plot(x(idB,1),x(idB,2),'k-',"LineWidth",1.5)
        elseif strcmp(geom,"cube")
            plot([max(x(idB,1)) max(x(idB,1)) min(x(idB,1)) min(x(idB,1)) max(x(idB,1))],...
                 [max(x(idB,2)) min(x(idB,2)) min(x(idB,2)) max(x(idB,2)) max(x(idB,2))],'k-',"LineWidth",1.5)
        end
        ax = gca;
        ax.FontSize = 18;
        xlabel("x","Interpreter","latex","FontSize",24)
        ylabel("y","Interpreter","latex","FontSize",24)
        zlabel("$$u_E$$","Interpreter","latex","FontSize",24,'Rotation',0)
        set(G,'EdgeColor','none')
        shading interp
    
        figure()
        G=trisurf(T,x(:,1),x(:,2),uNumeric);
        hold on
        if strcmp(geom,"ball")
            plot(x(idB,1),x(idB,2),'k-',"LineWidth",1.5)
        elseif strcmp(geom,"cube")
            plot([max(x(idB,1)) max(x(idB,1)) min(x(idB,1)) min(x(idB,1)) max(x(idB,1))],...
                 [max(x(idB,2)) min(x(idB,2)) min(x(idB,2)) max(x(idB,2)) max(x(idB,2))],'k-',"LineWidth",1.5)
        end
        ax = gca;
        ax.FontSize = 18;
        xlabel("x","Interpreter","latex","FontSize",24)
        ylabel("y","Interpreter","latex","FontSize",24)
        zlabel("$$u$$","Interpreter","latex","FontSize",24,'Rotation',0)
        set(G,'EdgeColor','none')
        shading interp
    
        figure()
        G=trisurf(T,x(:,1),x(:,2),error);
        hold on
        if strcmp(geom,"ball")
            plot(x(idB,1),x(idB,2),'k-',"LineWidth",1.5)
        elseif strcmp(geom,"cube")
            plot([max(x(idB,1)) max(x(idB,1)) min(x(idB,1)) min(x(idB,1)) max(x(idB,1))],...
                 [max(x(idB,2)) min(x(idB,2)) min(x(idB,2)) max(x(idB,2)) max(x(idB,2))],'k-',"LineWidth",1.5)
        end
        ax = gca;
        ax.FontSize = 18;
        xlabel("x","Interpreter","latex","FontSize",24)
        ylabel("y","Interpreter","latex","FontSize",24)
        zlabel("$$u-u_E$$","Interpreter","latex","FontSize",24)
        set(G,'EdgeColor','none')
        shading interp
    elseif dim == 3 && ~strcmp(geom,"cube")
        
        bndPtCloud = pointCloud(x(idB,:));
        surfMesh = pc2surfacemesh(bndPtCloud,"ball-pivot");
        x = surfMesh.Vertices;
        T = surfMesh.Faces;
        
        figure()
        G=trisurf(T,x(:,1),x(:,2),x(:,3),uAnalytic(idB));
        axis equal
        ax = gca;
        ax.FontSize = 18;
        xlabel("x","Interpreter","latex","FontSize",24)
        ylabel("y","Interpreter","latex","FontSize",24)
        zlabel("z","Interpreter","latex","FontSize",24,"Rotation",0)
        set(G,'EdgeColor','none')
        cb = colorbar;
        ylabel(cb,"$$u_E$$","Interpreter","latex","FontSize",24,'Rotation',0)
        shading interp
        
        figure()
        G=trisurf(T,x(:,1),x(:,2),x(:,3),uNumeric(idB));
        axis equal
        ax = gca;
        ax.FontSize = 18;
        xlabel("x","Interpreter","latex","FontSize",24)
        ylabel("y","Interpreter","latex","FontSize",24)
        zlabel("z","Interpreter","latex","FontSize",24,"Rotation",0)
        set(G,'EdgeColor','none')
        cb = colorbar;
        ylabel(cb,"$$u$$","Interpreter","latex","FontSize",24,'Rotation',0)
        shading interp
    
        figure()
        G=trisurf(T,x(:,1),x(:,2),x(:,3),error(idB));
        axis equal
        ax = gca;
        ax.FontSize = 18;
        xlabel("x","Interpreter","latex","FontSize",24)
        ylabel("y","Interpreter","latex","FontSize",24)
        zlabel("z","Interpreter","latex","FontSize",24,"Rotation",0)
        set(G,'EdgeColor','none')
        cb = colorbar;
        ylabel(cb,"$$u-u_E$$","Interpreter","latex","FontSize",24,'Rotation',90)
        shading interp
    else
        disp("No plotting availablein 3D for this geometry")
    end
end
%
% Point generation routine
%
function [data] = getPts(geom,N,n,C,R,mode,extCoeff)
    dim = size(C,2);
    if strcmp(geom,'ball')
        dimRat = [1 1.2*4/pi 1.2*8/(4*pi/3)];       % Ratios between rectangle/circle, cube/sphere area and volume
        dimACoeff = [1 pi (4/3)*pi];                % constant for size of domain
        dimPCoeff = [1 2*pi 4*pi];                  % constant for computing size of boundary
        h = R/(0.5*N^(1/dim) - extCoeff*n^(1/dim)); % approximate fill distance
        xB = zeros(0,dim);
        %
        % If using the unfitted method, no points on the boundary
        %
        if ~strcmp(mode,'unfitted')
            % Boundary point generation
            if dim == 1
                xB = [-R, R]';
            elseif dim == 2
                Nb = ceil((dimPCoeff(dim)*R^(dim-1))/(dimACoeff(dim-1)*h^(dim-1)));
                xB = [R*cos(linspace(-pi,pi-(2*pi)/(Nb+1),Nb)'), R*sin(linspace(-pi,pi-(2*pi)/(Nb+1),Nb)')];
            elseif dim == 3
                Nb = ceil((dimPCoeff(dim)*R^(dim-1))/(dimACoeff(dim-1)*(0.5*h)^(dim-1)));
                % Fibonacci points on sphere
                ratio = 1+sqrt(5);
                ind = [0:Nb-1]' + 0.5;
                theta = pi*ratio*ind;
                fi = acos(1-(2*ind)/(Nb));
                xB = [R.*sin(fi).*cos(theta), R.*sin(fi).*sin(theta), R.*cos(fi)];
            end
        end
        Nb = length(xB);
        % Interior point generation
        Ncube = ceil(dimRat(dim)*(N-Nb));
        x = 2*(R+n^(1/dim)*h*extCoeff)*(halton(Ncube,dim)-0.5);
        r2 = sqrt(sum(x.^2,2));
        pos = find(r2<=(R+n^(1/dim)*h*extCoeff));
        pos = pos(1:N-Nb);
        x = x(pos,:) + C;
        %
        % Organize outputs including labels for points inside, outside and on the boundary
        %
        data.nodes = [x; xB];
        data.inner = find(sqrt(sum((x+C).^2,2))<=R);
        data.outer = setdiff(1:size(x,1),data.inner)';
        data.bnd = [size(x,1) + 1:size(x,1) + size(xB,1)]';
        %
        % Domain volume and area measures used for the scaling of the LS problem
        %
        data.Vol = (dimACoeff(dim)*R^dim);
        data.Area = (dimPCoeff(dim)*R^(dim-1));
    elseif strcmp(geom,'cube')
        dimLCoeff = [1 sqrt(2)/2 sqrt(3)/3];          % constants for getting cube side length /2
        h = R/(0.5*N^(1/dim) - extCoeff*n^(1/dim));   % approximate fill distance
        xB = zeros(0,dim);
        %
        % If using the unfitted method, no points on the boundary
        %
        if ~strcmp(mode,'unfitted')
            % Boundary point generation
            if dim == 1
                xB = [-R, R]';
            elseif dim == 2
                Nb = ceil(((2*dimLCoeff(dim)*R)^(dim-1))/(h^(dim-1)));
                XYZLim = [-dimLCoeff(dim)*R dimLCoeff(dim)*R];
                xB = [linspace(XYZLim(1),XYZLim(2),Nb)', ones(Nb,1)*XYZLim(1);...
                      ones(Nb,1)*XYZLim(1), linspace(XYZLim(1),XYZLim(2),Nb)';...
                      linspace(XYZLim(1),XYZLim(2),Nb)', ones(Nb,1)*XYZLim(2);...
                      ones(Nb,1)*XYZLim(2), linspace(XYZLim(1),XYZLim(2),Nb)'];
                xB = unique(xB,'rows');
                xB = xB + C;
            elseif dim == 3
                NbF = ceil(((2*dimLCoeff(dim)*R)^(dim-1))/(h^(dim-1)));     % Number of points on each face
                NbE = ceil(2*dimLCoeff(dim)/h);                             % Number of points on each edge
                XYZLim = [-dimLCoeff(dim)*R dimLCoeff(dim)*R];
                xB = [linspace(XYZLim(1),XYZLim(2),NbE)', ones(NbE,1)*XYZLim(1), ones(NbE,1)*XYZLim(1);...
                      ones(NbE,1)*XYZLim(1), linspace(XYZLim(1),XYZLim(2),NbE)', ones(NbE,1)*XYZLim(1);...
                      linspace(XYZLim(1),XYZLim(2),NbE)', ones(NbE,1)*XYZLim(2), ones(NbE,1)*XYZLim(1);...
                      ones(NbE,1)*XYZLim(2), linspace(XYZLim(1),XYZLim(2),NbE)', ones(NbE,1)*XYZLim(1)];
                xB = [xB; [1,1,-1].*xB];
                Ry = eye(dim); Ry(1,1) = cos(pi/2); Ry(dim,dim) = cos(pi/2); Ry(dim,1) = -sin(pi/2); Ry(1,dim) = sin(pi/2); % Rotate 90 degrees along y-axis
                xB = [xB; (Ry*xB')'];
                xB = uniquetol(xB,1e-14,'ByRows',true);
                NbE = size(xB,1);
                Rx = eye(dim); Rx(dim-1,dim-1) = cos(pi/2); Rx(dim,dim) = cos(pi/2); Rx(dim-1,dim) = -sin(pi/2); Rx(dim,dim-1) = sin(pi/2); % Rotate 90 degrees
                xBF = [2*(dimLCoeff(dim)*R)*(halton(NbF,dim-1)-0.5), ones(NbF,1)*XYZLim(1)];
                xBF = [xBF; [1,1,-1].*xBF];
                xB = [xB; xBF];
                xB = [xB; (Rx*xBF')'];
                xB = [xB; (Ry*xBF')'];
            end
        end
        Nb = length(xB);
        % Interior point generation
        x = 2*(dimLCoeff(dim)*R+dimLCoeff(dim)*n^(1/dim)*h*extCoeff)*(halton(N-Nb,dim)-0.5);
        r2 = sqrt(sum(x.^2,2));
        x = x + C;
        %
        % Organize outputs including labels for points inside, outside and on the boundary
        %
        data.nodes = [x; xB];
        data.inner = find(all(abs(x-C)<=dimLCoeff(dim)*R,2));
        data.outer = setdiff(1:size(x,1),data.inner)';
        data.bnd = [size(x,1) + 1:size(x,1) + size(xB,1)]';
        %
        % Domain volume and area measures used for the scaling of the LS problem
        %
        data.Vol = (2*dimLCoeff(dim)*R)^dim;
        data.Area = 2*dim*(2*dimLCoeff(dim)*R)^(dim-1);
    end
end

% figure()
% xBplot = C + [R*cos(linspace(0,2*pi,1000))', R*sin(linspace(0,2*pi,1000))'];
% plot(xBplot(:,1),xBplot(:,2),'k-',"LineWidth",2.5)
% hold on
% plot(xc(:,1),xc(:,2),'rx','LineWidth',2,'MarkerSize',10)
% plot(xe(:,1),xe(:,2),'k.','LineWidth',2,'MarkerSize',15)
% plot(xeB(:,1),xeB(:,2),'b.','LineWidth',2,'MarkerSize',15)
% ax = gca;
% ax.FontSize = 18;
% xlabel("x","Interpreter","latex","FontSize",24)
% ylabel("y","Interpreter","latex","FontSize",24,'Rotation',0)
% legend('Domain, $$\Omega$$','Center points','Interior eval points','Boundary eval points',"Interpreter","latex",'Location','south','NumColumns',2,'Orientation','horizontal','FontSize',18)
% xlim(ax, [-1.2 1.2]);
% ylim(ax, [-1.8 1.2]);
% axis equal

end

