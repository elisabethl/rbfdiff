function [out1,out2,out3]=RBF_QR_diffmat_1D(ndiff,varargin)
% Alternative calls:
%        Psi = RBF_QR_diffmat(ndiff,xk,ep,C,R)  % First time on given domain 
% [A,Psi,Te] = RBF_QR_diffmat(ndiff,xk,ep,xe)   % First time implicit domain
%     [A,Te] = RBF_QR_diffmat(ndiff,Psi,xe)     % If Psi is already computed
%          A = RBF_QR_diffmat(ndiff,Psi,Te)     % If Psi and Te are computed
%
% Computes a differentiation matrix (weights for RBF-FD stencils)
% using Gaussian RBFs at evaluation point(s) xe for RBFs placed at
% the nodes xk. 
%
%--- op (chars)   : Alternatives '0', 'x', 'xx' or {'0','x',...}
%--- xe(1:Ne)  : The evaluation point(s) in Cartesian coordinates
%--- xk(1:N)  : The node points (no particular scaling assumed)
%--- ep (scalar)  : The (constant) shape parameter 
%--- Psi (struct) : Generated by a call to this function. Defines
%                   the RBF-QR basisfunctions Psi.
%
%--- Check if Psi exists. Otherwise, scale nodes and compute Psi.
computePsi = length(varargin) > 2;
evalTrue = length(varargin) <= 3;
domainGiven =  length(varargin) == 4;

if computePsi
    xk = varargin{1};
    ep = varargin{2};
    %
    % Find the center of the RBF-QR expansion, and center xk.
    %
    if domainGiven
        cc = varargin{3};
    else
        xmin = min(xk);
        xmax = max(xk);
        xe = varargin{3};
        if (size(xe,1) > 1) % Regular case
            xmin = min(xmin,min(xe));
            xmax = max(xmax,max(xe));
            cc = 0.5*(xmin + xmax);
        else
            cc = xe; % Stencil case, (the one) eval point = origin
        end
    end
    xk = xk - cc;
    %
    % Scale the nodes so that -1 and 1 are the extreme points 
    %         
    if domainGiven   
        rr = varargin{4}; 
    else
        rr = 0.5*(xmax-xmin); 
    end
    xk = (1/rr)*xk;
    ep = ep*rr;
    %
    % Compute Psi and save the transformation
    %
    [Psi] = InitPsi_1D(ep,xk);
    Psi.rr = rr;
    Psi.cc = cc;
    %
    % Compute and factorize the interpolation matrix which is reused for all ops
    %
    Psi.A0 = RBF_QR_mat_1D(Psi,'0',Psi.xk);
    [Psi.L,Psi.U,Psi.piv] = lu(Psi.A0,'vector');
else
    Psi = varargin{1};
    xe = varargin{2};
end  


if evalTrue
    if ~isstruct(xe) % Otherwise this is Te and already computed
        xe = xe-Psi.cc;
        xe = (1/Psi.rr)*xe;
    end    

    if (ndiff == 0)
        [A,Te] = eval_diffmat(Psi,'0',xe);     

    elseif (ndiff == 1)
        [A{1},Te] = eval_diffmat(Psi,'x',xe);

    elseif (ndiff == 1.5)
        [A,Te] = eval_diffmat(Psi,'xx',xe);
        %
        % In 1D the Hessian is the same as the Laplacian, but we include it for
        % congruens with other dimensions
        %
    elseif (ndiff == 2)
        [A{1,1},Te] = eval_diffmat(Psi,'xx',xe);
    end    
    %
    % We could also add higher order Laplacians here, but they are currently not
    % implemented in 1D.
    %
end

out1 = []; out2 = []; out3 = [];
if (domainGiven)
    out1 = Psi;
else
    out1 = A;
    if (computePsi)
        out2 = Psi;
        out3 = Te;
    else
        out2 = Te;
    end
end


function [A,Te] = eval_diffmat(Psi,op,xe)
%--- Compute the differentiation matrix
[A,Te] = RBF_QR_mat_1D(Psi,op,xe);
A = (A/Psi.U)/Psi.L;
A(:,Psi.piv) = A;
%--- Adjust the scaling according to derivative
deg = RBF_QR_parse(op);
A = (1/Psi.rr).^deg*A;

