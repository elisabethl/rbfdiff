function [out1,out2,out3] = RBF_QR_diffmat_3D(ndiff,varargin)
% Alternative calls:
%        Psi = RBF_QR_diffmat(ndiff,xk,ep,C,R) % First time fixed domain
% [A,Psi,Te] = RBF_QR_diffmat(ndiff,xk,ep,xe)  % First time implicit domain
%     [A,Te] = RBF_QR_diffmat(ndiff,Psi,xe)    % If Psi is already computed
%     [A,Te] = RBF_QR_diffmat(ndiff,Psi,Te)    % If Psi and Te exist
%
% Computes a differentiation matrix (weights for RBF-FD stencils)
% using Gaussian RBFs at evaluation point(s) xe for RBFs placed at
% the nodes xk.
%
%--- op (char)    : '0', 'x', 'y', 'z', 'L'
%                   If a cell array is given, differentiation matrices are
%                   returned in the same order in the cell array A.
%--- xe(1:M,1:3)  : The evaluation point(s) in Cartesian coordinates
%--- xk(1:N,1:3)  : The node points (no particular scaling assumed)
%--- ep (scalar)  : The (constant) shape parameter
%--- Psi (struct) : Generated by a call to this function. Defines
%                   the RBF-QR basisfunctions Psi.
%
computePsi = length(varargin) > 2;
evalTrue = length(varargin) <= 3;
domainGiven =  length(varargin) == 4;

if computePsi
    xk = varargin{1};
    ep = varargin{2};
    %
    % Find the center of the RBF-QR expansion, and center xk.
    %
    if domainGiven
        cc = varargin{3};
        rr = varargin{4};
    else
        xe = varargin{3};
        if (size(xe,1) > 1) % Regular case
            cc = mean(xk); % The nodes mainly define the domain 
        else
            cc = xe; % Stencil case, (the one) eval point = origin
        end
        xe = xe - cc;
        [lae,the,re] = cart2sph(xe(:,1),xe(:,2),xe(:,3));
        rr = max(re);
    end
    xk = xk - cc;
    [la,th,r] = cart2sph(xk(:,1),xk(:,2),xk(:,3));
    rr = max(rr,max(r)); % For a fixed domain, no nodes should be outside
    %
    % Transform the nodes to spherical and scale the nodes to radius one
    %
    xk = [(1/rr)*r pi/2-th la];
    ep = ep*rr;
    %
    % Compute Psi and save the transformation
    %
    Psi = InitPsi_3D(ep,xk);
    Psi.rr = rr;
    Psi.cc = cc;
    %--- Also compute the interpolation matrix which is reused for all ops 
    Psi.A0 = RBF_QR_mat_3D(Psi,'0',Psi.xk);

    %--- Factorize it and store the factors
    [Psi.L,Psi.U,Psi.piv] = lu(Psi.A0,'vector');
else
    Psi = varargin{1};
    xe = varargin{2};
    if ~isstruct(xe)
        xe = xe - Psi.cc; % Already done for the other case
        [lae,the,re] = cart2sph(xe(:,1),xe(:,2),xe(:,3));
    end    
end    

if evalTrue
    if ~isstruct(xe)
        xe = [(1/Psi.rr)*re pi/2-the lae];
    end

    if (ndiff==0)
        [A,Te] = eval_diffmat(Psi,'0',xe);

    elseif (ndiff == 1)
        [A{1},Te] = eval_diffmat(Psi,'x',xe);
        [A{2},Te] = eval_diffmat(Psi,'y',Te);
        [A{2},Te] = eval_diffmat(Psi,'z',Te);

    elseif (ndiff == 1.5)
        [A,Te] = eval_diffmat(Psi,'L',xe);

    elseif (ndiff == 2)
        [A{1,1},Te] = eval_diffmat(Psi,'xx',xe);
        [A{1,2},Te] = eval_diffmat(Psi,'xy',Te);
        [A{1,3},Te] = eval_diffmat(Psi,'xz',Te);
        [A{2,2},Te] = eval_diffmat(Psi,'yy',Te);
        [A{2,3},Te] = eval_diffmat(Psi,'yz',Te);
        [A{3,3},Te] = eval_diffmat(Psi,'zz',Te);
        A{2,1} = A{1,2};
        A{3,1} = A{1,3};
        A{3,2} = A{2,3};
    end
    %
    % L1-L4 seem to exist and should be included
    %
end

out1 = []; out2 = []; out3 = [];
if (domainGiven)
    out1 = Psi;
else
    out1 = A;
    if (computePsi)
        out2 = Psi;
        out3 = Te;
    else
        out2 = Te;
    end
end

function [A,Te] = eval_diffmat(Psi,op,xe)
%--- Compute the differentiation matrix
[A,Te] = RBF_QR_mat_3D(Psi,op,xe);
A = (A/Psi.U)/Psi.L;
A(:,Psi.piv) = A;
%--- Adjust the scaling according to derivative
deg = RBF_QR_parse(op);
A = (1/Psi.rr).^deg*A;


